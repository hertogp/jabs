#!/usr/bin/env python3
# -*- coding: utf-8  -*-

r'''
          _\|/_
          (o o)
  +----oOO-{_}-OOo-----------Syslog-----------------------------+
  |          __                  __                             |
  |         / /_   ___   ____ _ / /_ ____ ___   ____ _ ____     |
  |        / __ \ / _ \ / __ `// __// __ `__ \ / __ `// __ \    |
  |       / / / //  __// /_/ // /_ / / / / / // /_/ // /_/ /    |
  |      /_/ /_/ \___/ \__,_/ \__//_/ /_/ /_/ \__,_// .___/     |
  |                                                /_/          |
  |              syslog.csv --[+]--> syslog.xlsx                |
  |                            ^                                |
  |                            |                                |
  |                   [-i iface_map.csv]                        |
  +-------------------------------------------------------------+
  Splunk query for a suitable syslog.csv:
    index=network sourcetype=syslog
     [hostname(s)/filter]
     | rex field=_raw ".*%(?<code>.*?):\s*(?<msg>.*)"
     | table _time host code msg
'''

# ToDo:
# - add timeseries option:
#   - -t <start>,<stop>,period

import os
import sys
import re

import argparse
import pandas as pd

from xlsxwriter.utility import xl_range_abs, xl_col_to_name


def parseargs(argv):
    'parse commandline arguments, return arguments Namespace'
    p = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__)
    padd = p.add_argument
    padd('--verbose', '-v', action='count', help='verbose flag', default=0)
    padd('--iface-map', '-i', required=False, type=str, default='ifaces.csv',
         help='csv-file, fields: switch,iface,host[,..]')
    padd('--nokeep', '-n', required=False, action='store_true',
         help='donot keep ifaces without a mapping to a host')
    padd('--output', '-o', required=False, type=str, default='',
         help='output filename, default <infile>.xlsx')
    padd('syslog', help='syslog csv-file, fields:_time,host,code,msg')

    arg = p.parse_args(argv)
    if not arg.syslog.endswith('csv'):
        msg(0, 'Fatal: only digest csv-files, not ' + repr(arg.syslog))
        sys.exit(1)

    if not arg.output:
        arg.output = os.path.splitext(arg.syslog)[0] + '.xlsx'

    return arg


def read_syslog(fname):
    'turn syslog into dataframe with proper columns and a DatetimeIndex'
    try:
        df = pd.read_csv(fname)
    except (IOError, OSError):
        msg(0, 'Fatal: unreadable input file {}'.format(repr(args.syslog)))
        sys.exit(1)

    df.columns = df.columns.str.lower().str.replace('_', '')  # _time
    required = set('time host code msg'.split())
    intersect = set(df.columns.tolist()).intersection(required)
    if intersect != required:
        msg(0, 'Fatal: missing column(s): {}'.format(required - intersect))
        sys.exit(1)

    df = df.dropna()
    df.time = pd.to_datetime(df.time)
    df.set_index('time', inplace=True)
    df.sort_index(inplace=True)

    return df


def read_ifaces(fname):
    'turn iface map into dataframe with switch.iface as its index'
    try:
        df = pd.read_csv(fname)
    except (IOError, OSError):
        msg(0, 'iface map not provided or unreadable: skip this!')
        return pd.DataFrame()  # empty dataframe

    df.columns = df.columns.str.lower()
    required = set('switch iface host'.split())
    intersect = set(df.columns.tolist()).intersection(required)
    if intersect != required:
        msg(0, 'Non-fatal error in {}:'.format(args.iface_map),
            'missing column(s) {},'.format(required - intersect),
            'skipping interface map')
        return pd.DataFrame()

    # add idx-column as switch.iface, ensure iface is 1 letter + x/y/z
    rgx = re.compile('(?<=^.)[^0-9]+')
    df = df.assign(idx=df.switch.str.lower() +
                   '.' +
                   df.iface.str.lower().replace(to_replace=rgx,
                                                value='',
                                                regex=True))
    df.host = df.host.str.strip()
    df.set_index('idx', inplace=True)
    df.sort_index(inplace=True)

    return df


def limit_codes(syslog, codes=None):
    'limit syslogs to list of codes'
    if 'code' not in syslog.columns:
        msg(0, 'hmm, syslog is missing code column for limiting syslogs')
        return syslog
    if codes:
        syslog = syslog[syslog.code.isin(codes)]
    return syslog


def limit_times(df, start, end):
    'select rows at or after start and before end'
    # TODO: limit syslog by timebuckets, for now done in get_heatmap
    start = pd.to_datetime(start)
    end = pd.to_datetime(end)
    return df[(df.index >= start) & (df.index < end)]


def add_ifaces_column(df):
    'add iface=host.iface column to dataframe, extract iface from msg column'
    if 'msg' not in df.columns:
        msg(0, 'hmmm, df is missing msg column for iface extraction')
        return df

    rgx = re.compile('(?i)(?:interface)(?P<ifname>[^,]+?),')
    df = df.assign(iface=df.msg.str.extract(rgx, expand=True))

    # shorten iface-name and prepend host name
    rgx = re.compile('(?<=^..)[^0-9]+')
    df.iface = df.iface.replace(to_replace=rgx, value='', regex=True)
    df.iface = df.iface.str.lower().str.strip()
    df.iface = df.host.str.lower() + '.' + df.iface

    return df


def set_host_by_iface(syslog, ifaces, drop=True):
    'replace host in syslog with host in ifaces'
    if ifaces.empty:
        return syslog

    def lookup(iface):
        'lookup host by iface, return host, iface or None'
        try:
            row = ifaces.loc[iface]
        except KeyError:
            if drop:
                return None
            return iface
        return row.host

    syslog['host'] = syslog['iface'].apply(lookup)
    if drop:
        return syslog.dropna()
    return syslog


def get_heatmap(df, start=None, end=None, period='D'):
    'turn df with DatetimeIndex into heatmap df with hostxtime->count'
    if period not in ['D', 'h', 'M']:
        period = 'D'

    mx = df.groupby([df.index.to_period(period), 'host'])[['host']].size()
    # mx day,host->count Series => hostxday->count dataframe
    mx = mx.unstack(0, fill_value=0)

    return mx


def write_heatmap(fname, syslog, ifaces, heatmap):
    'write xlsx with sheets for heatmap, syslog and iface map'
    # nb: see https://xlsxwriter.readthedocs.io/format.html
    # - you can't format the dataframe's index in excell
    # - you cant read cell values with xslxwriter (its a writer)
    # - cell format > row format > column format
    writer = pd.ExcelWriter(fname)
    fmt_heatcells = writer.book.addformat({'align': 'center',
                                           'valign': 'vcenter',
                                           'bold': False,
                                           'font_name': 'mono',
                                           'font_size': 8})
    # heatmap sheet
    name, mx = 'heatmap', heatmap
    mx.to_excel(writer, name)
    sh = writer.sheets[name]
    sh.freeze_panes(1, 1)
    cells = xl_range_abs(1, 1, len(mx), len(mx.columns))
    sh.conditional_format(cells, {'type': '2_color_scale',
                                  'min_color': '#99ff99',
                                  'max_color': '#ff3300'})
    cols = 'B:{}'.format(xl_col_to_name(len(mx.columns)))
    sh.set_column('A:A', 40)
    sh.set_column(cols, 3, fmt_heatcells)

    # syslog sheet
    name, mx = 'syslog', syslog
    mx.to_excel(writer, name)
    sh = writer.sheets[name]
    sh.freeze_panes(1, 1)
    sh.set_column('A:A', 20)

    # ifaces sheet
    name, mx = 'ifaces', ifaces
    mx.to_excel(writer, name)
    sh = writer.sheets[name]
    sh.freeze_panes(1, 1)
    sh.set_column('A:A', 25)

    # Lastly, let the writer save it all
    writer.save()

    return 1


def msg(level, *a):
    'possibly print something'
    if args and level > args.verbose:
        return
    print(' '.join(str(i) for i in a), file=sys.stderr)


def main():
    'main func'
    try:
        syslog = read_syslog(args.syslog)     # index = DatetimeIndex (time)
        ifaces = read_ifaces(args.iface_map)  # index = switch.iface (idx)

        # - heatmap via UPDOWN messages
        updown = limit_codes(syslog, ['LINK-3-UPDOWN', 'LINEPROTO-5-UPDOWN'])
        updown = add_ifaces_column(updown)
        updown = set_host_by_iface(updown, ifaces, args.nokeep)

        # updown = add_ifaces(syslog, ['LINK-3-UPDOWN', 'LINEPROTO-5-UPDOWN'])

        msg(0, 'syslog - {} messages'.format(len(syslog.index)),
            '\nifaces - {} mappings found'.format(len(ifaces.index)),
            '\nupdown - {} messages seen'.format(len(updown.index)))

        heatmap = get_heatmap(updown)

        # Experimental - set heatmap column headers to short string
        heatmap.columns = heatmap.columns.strftime('%d-%m')
        suc6 = write_heatmap(args.output, syslog, ifaces, heatmap)
        if suc6:
            msg(0, 'success - see {} for results'.format(args.output))

    except (OSError, IOError) as e:
        msg(0, 'Error', repr(e))
        return 1

    return 0


if __name__ == '__main__':
    args = parseargs(sys.argv[1:])
    sys.exit(main())
