#!/usr/bin/env python3
# -*- coding: utf-8  -*-

r'''
          _\|/_
          (o o)
  +----oOO-{_}-OOo-----------Syslog-----------------------------+
  |          __                  __                             |
  |         / /_   ___   ____ _ / /_ ____ ___   ____ _ ____     |
  |        / __ \ / _ \ / __ `// __// __ `__ \ / __ `// __ \    |
  |       / / / //  __// /_/ // /_ / / / / / // /_/ // /_/ /    |
  |      /_/ /_/ \___/ \__,_/ \__//_/ /_/ /_/ \__,_// .___/     |
  |                                                /_/          |
  |              syslog.csv --[+]--> syslog.xlsx                |
  |                            ^                                |
  |                            |                                |
  |                   [-i iface_map.csv]                        |
  +-------------------------------------------------------------+
  Splunk query for a suitable syslog.csv:
    index=network sourcetype=syslog
     [hostname(s)/filter]
     | rex field=_raw ".*%(?<code>.*?):\s*(?<msg>.*)"
     | table _time host code msg
'''

# ToDo:
# - add timeseries option:
#   - -t <start>,<stop>,period

import os
import sys
import re

import argparse
import pandas as pd

from xlsxwriter.utility import xl_range_abs, xl_col_to_name


def parseargs(argv):
    'parse commandline arguments, return arguments Namespace'
    p = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__)
    padd = p.add_argument
    padd('--verbose', '-v', action='count', help='verbose flag', default=0)
    padd('--iface-map', '-i', required=False, type=str, default='',
         help='csv-file, fields: switch,iface,host[,..]')
    padd('--nokeep', '-n', required=False, action='store_true',
         help='donot keep ifaces without a mapping to a host')
    padd('--output', '-o', required=False, type=str, default='',
         help='output filename, default <infile>.xlsx')
    padd('--zoom', '-z', required=False, type=str, default='',
         help="start,stop,frequency csv-list to zoom in on")
    padd('--codes', '-c', required=False, type=str, default='',
         help="csv-list of codes to select for heatmap counting")
    padd('syslog', help='syslog csv-file, fields:_time,host,code,msg')

    arg = p.parse_args(argv)
    if not arg.syslog.endswith('csv'):
        msg(0, 'Fatal: only digest csv-files, not ' + repr(arg.syslog))
        sys.exit(1)

    if arg.codes:
        arg.codes = [x.strip() for x in arg.codes.split(',')]
    else:
        arg.codes = ['LINK-3-UPDOWN', 'LINEPROTO-5-UPDOWN']

    if arg.zoom:
        arg.zoom = arg.zoom.split(',')
        if len(arg.zoom) != 3:
            raise Exception('zoom needs start,stop,freq as csv-list!')
        arg.zoom[:2] = pd.to_datetime(arg.zoom[0]), pd.to_datetime(arg.zoom[1])
    else:
        arg.zoom = [pd.NaT, pd.NaT, 'D']

    if not arg.output:
        arg.output = os.path.splitext(arg.syslog)[0] + '.xlsx'

    print(arg)
    return arg


def read_syslog(fname):
    'turn syslog into dataframe with proper columns and a DatetimeIndex'
    try:
        df = pd.read_csv(fname)
    except (IOError, OSError):
        msg(0, 'Fatal: unreadable input file {}'.format(repr(args.syslog)))
        sys.exit(1)

    df.columns = df.columns.str.lower().str.replace('_', '')  # _time
    required = set('time host code msg'.split())
    intersect = set(df.columns.tolist()).intersection(required)
    if intersect != required:
        msg(0, 'Fatal: missing column(s): {}'.format(required - intersect))
        sys.exit(1)

    df = df.dropna()
    df.time = pd.to_datetime(df.time)
    df.set_index('time', inplace=True)
    df.sort_index(inplace=True)
    msg(0, 'read_syslog', len(df.index), df.index.min(), df.index.max())

    return df


def read_ifaces(fname):
    'turn iface map into dataframe with switch.iface as its index'
    try:
        df = pd.read_csv(fname)
    except (IOError, OSError):
        msg(0, 'iface map not provided or unreadable: skip this!')
        return pd.DataFrame()  # empty dataframe

    df.columns = df.columns.str.lower()
    required = set('switch iface host'.split())
    intersect = set(df.columns.tolist()).intersection(required)
    if intersect != required:
        msg(0, 'Non-fatal error in {}:'.format(args.iface_map),
            'missing column(s) {},'.format(required - intersect),
            'skipping interface map')
        return pd.DataFrame()

    # add idx-column as switch.iface, ensure iface is 1 letter + x/y/z
    rgx = re.compile('(?<=^.)[^0-9]+')
    df = df.assign(idx=df.switch.str.lower() +
                   '.' +
                   df.iface.str.lower().replace(to_replace=rgx,
                                                value='',
                                                regex=True))
    df.host = df.host.str.strip()
    df.set_index('idx', inplace=True)
    df.sort_index(inplace=True)

    return df


def limit_codes(syslog, codes=None):
    'limit syslogs to list of codes'
    if 'code' not in syslog.columns:
        msg(0, 'hmm, syslog is missing code column for limiting syslogs')
        return syslog
    if codes:
        syslog = syslog[syslog.code.isin(codes)]
    return syslog


def limit_times(df, start, end):
    'select rows at or after start and before end'
    if pd.isnull(start) and pd.isnull(end):
        msg(0, 'no start,end, returning df')
        return df
    start = df.index.min() if pd.isnull(start) else start
    end = df.index.max() if pd.isnull(end) else end

    return df[(df.index >= start) & (df.index < end)]


def add_ifaces_column(df):
    'add iface=host.iface column to dataframe, extract iface from msg column'
    if 'msg' not in df.columns:
        msg(0, 'hmmm, df is missing msg column for iface extraction')
        return df

    # new iface col = long interface name extracted from msg column
    # TODO: currently rgx is for LINK-3-UPDOWN/LINEPROTO msg's
    #       other commands with interface <iface> without comma wont match!
    rgx = re.compile('(?i)(?:interface)(?P<ifname>[^,]+?),')
    df = df.assign(iface=df.msg.str.extract(rgx, expand=True))

    # then shorten iface-name and prepend host name
    rgx = re.compile('(?<=^..)[^0-9]+')
    df['iface'] = df.iface.replace(to_replace=rgx, value='', regex=True)
    df.iface = df.iface.fillna('?')
    print(df.iface)
    df['iface'] = df.iface.str.lower().str.strip()
    df['iface'] = df.host.str.lower() + '.' + df.iface

    return df


def set_host_by_iface(syslog, ifaces, drop=True):
    'replace host in syslog with host in ifaces'
    if ifaces.empty:
        return syslog

    def lookup(iface):
        'lookup host by iface, return host, iface or None'
        print('lookup', iface)
        try:
            row = ifaces.loc[iface]
        except KeyError:
            if drop:
                return None
            return iface
        return row.host

    syslog['host'] = syslog['iface'].apply(lookup)
    if drop:
        return syslog.dropna()
    return syslog


def get_heatmap(df, start, end, freq):
    'turn df with DatetimeIndex into heatmap df with hostxtime->count'
    # df has datetime index and at least an iface column
    start = df.index.min() if pd.isnull(start) else start
    end = df.index.max() if pd.isnull(end) else end
    print('get_heat')
    print(' - start', start)
    print(' - end', end)
    mx = df[(df.index >= start) & (df.index < end)]
    mx = mx.groupby([mx.index.name, 'host']).size()
    mx = mx.unstack(level=-1, fill_value=0)
    mx = mx.resample(freq).sum()
    return mx.T.fillna(0)


def write_heatmap(fname, syslog, ifaces, heatmap):
    'write xlsx with sheets for heatmap, syslog and iface map'
    # nb: see https://xlsxwriter.readthedocs.io/format.html
    # - you can't format the dataframe's index in excell
    # - you cant read cell values with xslxwriter (its a writer)
    # - cell format > row format > column format
    writer = pd.ExcelWriter(fname)
    fmt_heatcells = writer.book.add_format({'align': 'center',
                                            'valign': 'vcenter',
                                            'bold': False,
                                            'font_name': 'mono',
                                            'font_size': 8})
    # heatmap sheet
    name, mx = 'heatmap', heatmap
    mx.to_excel(writer, name)
    sh = writer.sheets[name]
    sh.freeze_panes(1, 1)
    cells = xl_range_abs(1, 1, len(mx), len(mx.columns))
    sh.conditional_format(cells, {'type': '2_color_scale',
                                  'min_color': '#99ff99',
                                  'max_color': '#ff3300'})
    cols = 'B:{}'.format(xl_col_to_name(len(mx.columns)))
    sh.set_column('A:A', 40)
    sh.set_column(cols, 3, fmt_heatcells)

    # syslog sheet
    name, mx = 'syslog', syslog
    mx.to_excel(writer, name)
    sh = writer.sheets[name]
    sh.freeze_panes(1, 1)
    sh.set_column('A:A', 20)

    # ifaces sheet
    name, mx = 'ifaces', ifaces
    mx.to_excel(writer, name)
    sh = writer.sheets[name]
    sh.freeze_panes(1, 1)
    sh.set_column('A:A', 25)

    # Lastly, let the writer save it all
    writer.save()

    return 1


def msg(level, *a):
    'possibly print something'
    if args and level > args.verbose:
        return
    print(' '.join(str(i) for i in a), file=sys.stderr)


def main():
    'main func'
    try:
        syslog = read_syslog(args.syslog)     # index = DatetimeIndex (time)
        ifaces = read_ifaces(args.iface_map)  # index = switch.iface (idx)

        slines = limit_codes(syslog, args.codes)
        if not(len(slines)):
            msg(0, 'fatal, code filter leaves no entries:', args.codes)
            sys.exit(1)

        slines = limit_times(slines, *args.zoom[0:2])
        if not(len(slines)):
            msg(0, 'fatal: time filter leaves no entries:', args.zoom[0:2])
            sys.exit(1)

        slines = add_ifaces_column(slines)
        slines = set_host_by_iface(slines, ifaces, args.nokeep)
        msg(0, 'syslog - {} messages'.format(len(syslog.index)),
            '\nifaces - {} mappings found'.format(len(ifaces.index)),
            '\nslines - {} messages seen'.format(len(slines.index)))
        heatmap = get_heatmap(slines, *args.zoom)

        # Experimental - set heatmap column headers to short string
        # heatmap.columns = heatmap.columns.strftime('%d-%m')
        freq = args.zoom[2]
        print('freq', freq)
        if 'T' in freq:
            tfmt = '%d-%m %H:%M'
        elif 'H' in freq:
            tfmt = '%d-%m %H'
        elif 'M' in freq:
            tfmt = '%Y-%m'
        else:
            tfmt = '%d-%m'
        heatmap.columns = heatmap.columns.strftime(tfmt)

        suc6 = write_heatmap(args.output, syslog, ifaces, heatmap)
        if suc6:
            msg(0, 'success - see {} for results'.format(args.output))

    except (OSError, IOError) as e:
        msg(0, 'Error', repr(e))
        return 1

    return 0


if __name__ == '__main__':
    args = parseargs(sys.argv[1:])
    sys.exit(main())
